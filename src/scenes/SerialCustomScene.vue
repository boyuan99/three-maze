<script setup>
import { onMounted, onBeforeUnmount, ref, shallowRef } from 'vue'
import { useRoute } from 'vue-router'
import { scenes } from '@/scenes'
import { SerialCustomWorld } from '@/worlds/SerialCustomWorld'

const route = useRoute()
const canvas = ref(null)
const world = shallowRef(null)
const showInfo = ref(true)
const sceneName = ref('Serial Custom Scene')
const sceneDescription = ref('A custom scene for serial control')
const error = ref(null)
const position = ref({ x: 0, y: 0, theta: 0 })

onMounted(async () => {
  console.log('SerialCustomScene: Mounting component')
  console.log('SerialCustomScene: Route params:', route.params)
  console.log('SerialCustomScene: Available scenes:', scenes)

  if (!canvas.value) {
    console.error('SerialCustomScene: Canvas not found')
    return
  }

  let sceneConfig = null
  const sceneId = route.params.id
  console.log('SerialCustomScene: Looking for scene with ID:', sceneId)

  if (window.electron) {
    console.log('SerialCustomScene: Running in Electron mode')
    try {
      // Add a small delay to ensure IPC is ready
      await new Promise(resolve => setTimeout(resolve, 500))

      const data = await window.electron.getSceneConfig()
      console.log('SerialCustomScene: Received data from electron:', data)

      if (data && data.config) {
        sceneConfig = data.config
        console.log('SerialCustomScene: Got config from electron:', sceneConfig)
        
        // 设置控制器文件自动加载的处理
        window.electron.onLoadControllerFile((controllerData) => {
          console.log('SerialCustomScene: Received controller file:', controllerData)
          if (controllerData && controllerData.controllerPath) {
            console.log('SerialCustomScene: Auto-loading controller file:', controllerData.controllerPath)
            // 调用加载控制器文件的逻辑
            window.electron.sendMessage('load-controller', {
              controllerPath: controllerData.controllerPath
            })
          }
        })
      } else {
        console.error('SerialCustomScene: No config in electron data')
      }
    } catch (err) {
      console.error('SerialCustomScene: Error getting config from electron:', err)
      error.value = 'Failed to get scene configuration from Electron'
    }
  } else {
    console.log('SerialCustomScene: Running in browser mode')
    const scene = scenes.find(s => s.id === sceneId)
    console.log('SerialCustomScene: Found scene:', scene)
    sceneConfig = scene?.config
  }

  if (!sceneConfig) {
    const errorMsg = 'Scene configuration not found for: ' + sceneId
    console.error('SerialCustomScene:', errorMsg)
    error.value = errorMsg
    return
  }

  // Update scene info
  console.log('SerialCustomScene: Initializing with config:', sceneConfig)
  sceneName.value = sceneConfig.name
  sceneDescription.value = sceneConfig.description || 'A custom scene for serial control'

  // Initialize world with configuration
  try {
    world.value = new SerialCustomWorld(canvas.value, sceneConfig)
    await world.value.init()
    console.log('SerialCustomScene: World initialized successfully')
    
    // Seting serial data processing  
    if (window.electron) {
      // Add serial data listener
      window.electron.onSerialData((data) => {
        if (world.value) {
          // Update position information
          if (world.value.playerBody) {
            const playerPos = world.value.playerBody.translation()
            position.value.x = playerPos.x
            position.value.y = playerPos.z
            
            // Get rotation angle
            const rotation = world.value.playerBody.rotation()
            position.value.theta = rotation.y
          }
          
          // Pass data to world object
          world.value.updateFromSerialData(data)
        }
      })
      
      // Add error listener
      window.electron.onSerialError((errorMsg) => {
        error.value = errorMsg
      })
    }
  } catch (err) {
    console.error('SerialCustomScene: Error initializing world:', err)
    error.value = 'Error initializing world: ' + err.message
  }
})

onBeforeUnmount(() => {
  console.log('SerialCustomScene: Unmounting component')
  if (world.value) {
    world.value.dispose()
    world.value = null
  }
  
  // Clean up serial connection
  if (window.electron) {
    window.electron.stopSerialConnection && window.electron.stopSerialConnection()
  }
})
</script>

<template>
  <div class="scene-container">
    <canvas ref="canvas"></canvas>

    <!-- Error Display -->
    <div v-if="error" class="error-overlay">
      <div class="error-content">
        <h3>Error</h3>
        <p>{{ error }}</p>
      </div>
    </div>

    <!-- Info Overlay -->
    <div v-else-if="showInfo" class="overlay-info">
      <div class="info-panel">
        <h3>{{ sceneName }}</h3>
        <p>{{ sceneDescription }}</p>
        <p>Serial Control Instructions:</p>
        <ul>
          <li>Connect your device to a serial port</li>
          <li>Use the serial monitor to view data</li>
          <li>Send commands to control the scene</li>
        </ul>
        <!-- Display position information -->
        <p>Position:</p>
        <ul>
          <li>X: {{ position.x.toFixed(2) }}</li>
          <li>Y: {{ position.y.toFixed(2) }}</li>
          <li>θ: {{ position.theta.toFixed(2) }}</li>
        </ul>
      </div>
      <button class="toggle-info" @click="showInfo = false">Hide Info</button>
    </div>
    <button
      v-else
      class="toggle-info-mini"
      @click="showInfo = true"
    >
      Show Info
    </button>
  </div>
</template>

<style scoped>
.scene-container {
  width: 100vw;
  height: 100vh;
  position: relative;
  overflow: hidden;
}

canvas {
  width: 100%;
  height: 100%;
}

.overlay-info {
  position: absolute;
  top: 20px;
  right: 20px;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 10px;
}

.info-panel {
  background: rgba(0, 0, 0, 0.7);
  padding: 20px;
  border-radius: 8px;
  color: white;
  min-width: 200px;
}

.info-panel h3 {
  margin: 0 0 15px 0;
  text-align: center;
}

.info-panel ul {
  margin: 0;
  padding-left: 20px;
}

.info-panel li {
  margin: 5px 0;
}

button {
  padding: 8px 12px;
  background: rgba(0, 0, 0, 0.5);
  border: none;
  border-radius: 4px;
  color: white;
  cursor: pointer;
  transition: background 0.3s ease;
}

button:hover {
  background: rgba(0, 0, 0, 0.7);
}

.toggle-info-mini {
  position: absolute;
  top: 20px;
  right: 20px;
}

.error-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.error-content {
  background: #2a2a2a;
  padding: 2rem;
  border-radius: 8px;
  max-width: 400px;
  text-align: center;
}

.error-content h3 {
  color: #ff4444;
  margin-bottom: 1rem;
}

.error-content p {
  color: white;
  margin: 0;
}
</style>